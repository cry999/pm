package main

import (
	"bufio"
	"bytes"
	"compress/zlib"
	"encoding/hex"
	"flag"
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

const (
	gomod    = "go.mod"
	tempRead = `// This file is auto-generated by pack. DO NOT EDIT
package {{ .packageName }}

import (
	"bytes"
	"compress/zlib"
	"fmt"
	"encoding/hex"
	"io"
)

// Read an embedded file
func Read(name string) (io.Reader, error) {
	hexed, ok := files[name]
	if !ok {
		return nil, fmt.Errorf("%s: no such file or directory", name)
	}
	compressed, err := hex.DecodeString(string(hexed))
	if err != nil {
		return nil, fmt.Errorf("%s: %v", name, err)
	}
	return zlib.NewReader(bytes.NewReader(compressed))
}
`
)

func main() {
	var (
		opath       string
		ipath       string
		packageName string
		recursive   bool
	)
	flag.Usage = func() {
		fmt.Fprintf(os.Stderr, strings.Join([]string{
			"USAGE: %s [Options] input output",
			"",
			"ARGS:",
			"\tinput: input file/directory name. When input starts with '/', this",
			"\t\tis interpreted a relative path from project root. When not, this",
			"\t\tis interpreted a relative path from $PWD. And, when input is directory,",
			"\t\tyou should specify recursive flag.",
			"",
			"\toutput: output directory name. Interpretation of the path is defined",
			"\t\ton `input` args section.",
			"",
			"\t\texample) project root (where go.mod is) is /my/app",
			"\t\t\t$ pwd",
			"\t\t\t// /my/app/path",
			"\t\t\t$ %s input /output",
			"\t\t\t// input => /my/app/path/input, output => /my/app/output",
			"",
			"OPTIONS:",
			"",
		}, "\n"), os.Args[0], os.Args[0])
		flag.PrintDefaults()
	}
	flag.StringVar(&packageName, "package-name", "", "output file's package name. default is same as `opath`.")
	flag.BoolVar(&recursive, "recursive", false, "search on recursive? default is `false`")
	flag.Parse()

	if flag.NArg() != 2 {
		flag.Usage()
		os.Exit(1)
	}
	pwd, err := os.Getwd()
	if err != nil {
		printError("unknown current working directory: %v", err)
	}
	_, projectRoot, err := findProjectRoot(pwd)
	if err != nil {
		printError("%s: here is not go project", pwd)
	}
	ipath = fixpath(pwd, projectRoot, flag.Arg(0))
	opath = fixpath(pwd, projectRoot, flag.Arg(1))
	if packageName == "" {
		packageName = filepath.Base(opath)
	}

	if stat, err := os.Stat(opath); os.IsNotExist(err) {
		if err := os.MkdirAll(opath, 0o755); err != nil {
			printError("opath: %s: failed to create: %v", opath, err)
		}
	} else if !stat.IsDir() {
		printError("opath: %s: is not directory", opath)
	}
	outfile := filepath.Join(opath, "asset.go")
	fp, err := os.OpenFile(outfile, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0o644)
	if err != nil {
		printError("opath: %s: %v", outfile, err)
	}
	defer fp.Close()

	if stat, err := os.Stat(ipath); os.IsNotExist(err) {
		printError("ipath: %s: does not exist", ipath)
	} else if stat.IsDir() && !recursive {
		printError("ipath: %s: is directory. Please specify -recursive=true", ipath)
	}

	fmt.Fprintf(fp, "// This file is auto generated by pack. DO NOT EDIT\n")
	fmt.Fprintf(fp, "package %s\n", packageName)
	fmt.Fprintf(fp, "\n")
	fmt.Fprintf(fp, "var files = map[string][]byte{\n")
	if err := pack(fp, ipath, projectRoot); err != nil {
		printError("pack: %v", err)
	}
	fmt.Fprintf(fp, "}\n")

	utilfile := filepath.Join(opath, "util.go")
	utilfp, err := os.OpenFile(utilfile, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0o644)
	if err != nil {
		printError("%s: cannot create: %v", utilfile, err)
	}
	if err := template.Must(template.New("temp").Parse(tempRead)).Execute(utilfp, map[string]string{
		"packageName": packageName,
	}); err != nil {
		printError("%s: cannot write: %v", utilfile, err)
	}
}

func fixpath(wd, projectRoot, path string) string {
	if strings.HasPrefix(path, "/") {
		// relative from `project root`
		return filepath.Join(projectRoot, path)
	}
	// relative from `working directory`
	return filepath.Join(wd, path)
}

func pack(out io.Writer, root, projectRoot string) error {
	if stat, _ := os.Stat(root); stat.IsDir() {
		fileinfos, err := ioutil.ReadDir(root)
		if err != nil {
			return fmt.Errorf("%s: %v", root, err)
		}
		for _, fi := range fileinfos {
			abs := filepath.Join(root, fi.Name())
			if err := pack(out, abs, projectRoot); err != nil {
				return err
			}
		}
	} else {
		fp, err := os.OpenFile(root, os.O_RDONLY, 0o644)
		if err != nil {
			return fmt.Errorf("%s: %v", root, err)
		}
		defer fp.Close()

		var buf bytes.Buffer
		compressor := zlib.NewWriter(&buf)
		for {
			if n, err := io.Copy(compressor, fp); err != nil || n == 0 {
				if err == io.EOF || n == 0 {
					break
				}
				return fmt.Errorf("%s: %v", root, err)
			}
		}
		compressor.Close()

		key, err := filepath.Rel(projectRoot, root)
		if err != nil {
			return fmt.Errorf("%s: %v", root, err)
		}
		fmt.Fprintf(out, "\t\"%s\": []byte(`%s`),\n", key, hex.EncodeToString(buf.Bytes()))
	}
	return nil
}

func findProjectRoot(root string) (mod, path string, err error) {
	gomodFile := filepath.Join(root, gomod)
	if _, err := os.Stat(gomodFile); os.IsNotExist(err) {
		dir := filepath.Dir(root)
		if dir == "/" {
			return "", root, fmt.Errorf("not project path")
		}
		return findProjectRoot(dir)
	}
	fp, err := os.Open(gomodFile)
	if err != nil {
		return "", root, fmt.Errorf("%s/go.mod: %v", root, err)
	}
	defer fp.Close()

	reader := bufio.NewReader(fp)
	for {
		maybe, err := reader.ReadString('\n')
		if err != nil {
			if err == io.EOF {
				return "", root, fmt.Errorf("go.mod: no module name")
			}
			return "", root, fmt.Errorf("%s/go.mod: %v", root, err)
		}
		if strings.HasPrefix(strings.Trim(maybe, " \t"), "module") {
			sp := strings.Split(maybe, " ")
			if len(sp) != 2 {
				return "", "", fmt.Errorf("go.mod: invalid module line: %s", maybe)
			}
			// success
			return sp[1], root, nil
		}
	}
}

func printError(s string, a ...interface{}) {
	fmt.Fprintf(os.Stderr, s+"\n", a...)
	os.Exit(1)
}
